Has A 상속

캡슐로 연결된 것들을 어떻게 엮어낼 것인가.

실질적으로 사용하는 객체의 관계와 그들이 구성하고 있는 관계가 일치하지 않음.
-> 복잡해보이는 도식이 그려짐.
사용관계와 구성관계가 일치하도록 도식화함.
하나의 클래스가 다른 클래스를 가지고 있는 관계 = Has A 상속
-> Has A는 부품으로 물려받았다. 라고 함.
그 부품은 자기가 구현해야할 기능을 구현할 때 도구로 사용할 수 있는 형태로써 부품으로 갖는다 라고함.
Has A 상속 : 한 캡슐이 다른 캡슐의 객체을 가지고 있는 상태.
속이 찬 마름모와 직선 = Composition Has A
속이 빈 마름모와 직선 = Aggregation Has A
Composition : 집합과 상관 없이 다른 캡슐의 객체를 가진 캡슐의 클래스의 구성되는 것들을 같이 만들 것인가.
다른 캡슐의 객체를 가지지 않은 캡슐의 클래스를 만들 때 필요로하는 다른 캡슐의 객체를 한 번에 다 가지고 있는 상태.
Aggregation : Association을 집합적으로 갖는다.

		Composition은 애초에 만들때 한번에 다 만들어놓고 시작을 하는 것.
		Aggregation은 필요할 때 마다 하나씩 만들어 누적시켜 사용하는 것.?

-성적입력 프로그램의 경우 성적을 입력할 때마다 하나씩 만들어 사용해야하므로 Aggregation Has A 상속을 사용한다.
input이나 print를 구현할 때 그 안에서 일시적으로 객체를 생성해서 사용하는 경우 : Dependency : 점선
Dependency = 의존객체 = 사용할 수 있는 부품 -> 함수 내에서 사용하고 말아버리는 객체 ex)Scanner

Composition은 애초에 만들때 한번에 다 만들어놓고 시작을 하는 것.
Composition Has A = 일체형
클래스가 만들어질 때 멤버변수로써 바로 만들어지는 것.
멤버변수가 있는 필드는 연산자가 있으면 안된다.사용이 불가능하다.메소드 또는 함수 안에서만 사용이 가능했음.
그래서 멤버변수로써는 선언만 하고 생성자 안에서 초기화를 시켜줌.
즉 해당 객체가 생성될때 딸려옴.
이게 Composition Has A 상속 관계이다.

Aggregation은 필요할 때 마다 하나씩 만들어 사용하는 것.
멤버변수가 배열이면서 클래스객체가 생성될 때 생성자로 배열이 딸려오는 경우 
객체가 아닌 참조변수를 만든 것이기 때문에 Composition Has A 상속이 아니다.
이 때는 Aggregation Has A 상속 관계이다. 
생성자와 참조변수(문자열, 배열)의 (앞으로 추가될 객체와의) 관계가 Aggregation Has A 상속 관계이다.
=참조변수가 만들어지는 시기와 참조변수에 담겨지는 객체의 생명주기가 다르다.

즉, Composition 은 객체가 만들어 질 때 생성자에서 또 다른 객체(부품) 만들어지는 것.
Aggregation은 참조변수가 만들어 지고 나서 필요할 때에 객체가 누적되는것?
